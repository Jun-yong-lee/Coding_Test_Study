"""
1. 아이디어
- 각 행(row)에는 반드시 하나의 퀸만 놓이도록 DFS를 수행
- 열(column), 두 대각선 방향(\, /)에 이미 퀸이 존재하는지 여부를 배열로 관리하여 충돌 여부를 빠르게 판단
- 현재 행 n에서 가능한 열 j를 순회하며,
  해당 위치가 열/대각선 모두에서 안전한 경우에만 퀸을 배치하고 다음 행(n+1)으로 재귀 호출
- 충돌이 발생하는 경우는 dfs 호출 자체를 하지 않음으로써 가지치기(backtracking) 수행
- n == N이 되면 N개의 퀸을 모두 배치한 것이므로 정답 개수 증가

2. 시간복잡도
- 최악의 경우 각 행마다 모든 열을 탐색하므로 시간복잡도는 O(N!)
- 하지만 열과 대각선 충돌을 사전에 검사하여 많은 경우를 가지치기하므로,
  실제 수행 시간은 N!보다 훨씬 작음
3. 변수
- N: int, 체스판의 크기이자 배치해야 할 퀸의 개수
- ans: int, 조건을 만족하는 퀸 배치 경우의 수
- dfs(n): 함수, n번째 행에 퀸을 배치하는 재귀 함수
- v1: list[int], 열(column) 충돌 체크 배열
       v1[j] == 1이면 j번째 열에 이미 퀸이 존재
- v2: list[int], \ 방향 대각선 충돌 체크 배열
       인덱스는 (row + col)
- v3: list[int], / 방향 대각선 충돌 체크 배열
       인덱스는 (row - col)
"""

import sys
input = sys.stdin.readline

def dfs(n):
    global ans
    if n==N:
        ans += 1
        return
    
    for j in range(N):
        if v1[j] == v2[n+j] == v3[n-j] == 0:
            v1[j] = v2[n+j] = v3[n-j] = 1
            dfs(n+1)
            v1[j] = v2[n+j] = v3[n-j] = 0

N = int(input())
ans = 0
v1 = [0] * N # 세로 충돌 체크
v2 = [0] * (2*N) # \ 왼쪽 위에서 오른쪽 아래 방향 대각선 (row + col 일정)
v3 = [0] * (2*N) # / 오른쪽 위에서 왼쪽 아래 방향 대각선 (row - col 일정)
dfs(0)
print(ans)